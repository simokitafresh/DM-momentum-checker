<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>デュアルモメンタム戦略チェッカー・MVP</title>
  <style>
    /* ベーススタイル */
    body { 
      font-family: monospace; 
      max-width: 900px; 
      margin: 24px auto; 
      padding: 16px; 
      box-sizing: border-box;
    }
    
    h1 { 
      font-size: 20px; 
      text-align: center;
      margin-bottom: 24px;
    }
    
    form { 
      display: grid; 
      gap: 12px; 
    }
    
    .row { 
      display: grid; 
      gap: 8px; 
      grid-template-columns: 160px 1fr; 
      align-items: start; 
    }
    
    label { 
      font-weight: bold;
      padding-top: 8px; /* inputの高さに合わせて調整 */
    }
    
    input, select, button { 
      padding: 8px; 
      font-family: inherit; 
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    
    button {
      background-color: #007acc;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }
    
    button:hover {
      background-color: #005a9e;
    }
    
    .tickers { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); 
      gap: 8px; 
    }
    
    .hint { 
      color: #666; 
      font-size: 12px; 
      margin-top: 4px;
    }
    
    .error { 
      color: #c00; 
    }
    
    #results { 
      margin-top: 16px; 
      white-space: pre-wrap; 
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 12px;
      font-family: monospace;
      min-height: 60px;
    }
    
    .anchors { 
      margin-top: 8px; 
      font-size: 12px; 
      color: #555; 
    }
    
    .notice { 
      color: #06c; 
      font-weight: bold;
    }

    /* タブレット対応 (768px以下) */
    @media (max-width: 768px) {
      body {
        margin: 16px auto;
        padding: 12px;
      }
      
      h1 {
        font-size: 18px;
        margin-bottom: 20px;
      }
      
      .row {
        grid-template-columns: 1fr;
        gap: 6px;
      }
      
      label {
        padding-top: 0;
        margin-bottom: 4px;
      }
      
      .tickers {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 6px;
      }
      
      input, select, button {
        padding: 10px;
        font-size: 16px; /* iOS Safariでのzoom防止 */
      }
      
      #results {
        font-size: 14px;
        padding: 10px;
      }
    }

    /* スマートフォン対応 (480px以下) */
    @media (max-width: 480px) {
      body {
        margin: 8px auto;
        padding: 8px;
      }
      
      h1 {
        font-size: 16px;
        margin-bottom: 16px;
      }
      
      .tickers {
        grid-template-columns: 1fr;
        gap: 8px;
      }
      
      input, select, button {
        padding: 12px;
        font-size: 16px;
      }
      
      button {
        padding: 14px;
        font-size: 16px;
        font-weight: bold;
      }
      
      #results {
        font-size: 13px;
        padding: 8px;
        line-height: 1.4;
      }
      
      .hint {
        font-size: 11px;
      }
    }

    /* 超小画面対応 (360px以下) */
    @media (max-width: 360px) {
      body {
        margin: 4px auto;
        padding: 6px;
      }
      
      h1 {
        font-size: 14px;
        margin-bottom: 12px;
      }
      
      form {
        gap: 10px;
      }
      
      .row {
        gap: 4px;
      }
    }
  </style>
  <link rel="icon" href="data:," />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
</head>
<body>
  <h1>デュアルモメンタム戦略チェッカー</h1>

  <form id="momentum-form">
    <div class="row">
      <label>Tickers (最大3個)</label>
      <div class="tickers">
        <input class="ticker-input" placeholder="AAPL" />
        <input class="ticker-input" placeholder="MSFT" />
        <input class="ticker-input" placeholder="GOOGL" />
      </div>
    </div>

    <div class="row">
      <label for="unit">Unit</label>
      <select id="unit">
        <option value="month">month</option>
        <option value="week">week</option>
        <option value="day">day</option>
      </select>
    </div>

    <div class="row">
      <label for="n">N (過去期間)</label>
      <input id="n" type="number" min="1" value="3" />
    </div>

    <div class="row">
      <label for="as_of_period">基準日</label>
      <div>
        <input id="as_of_period" type="month" placeholder="YYYY-MM" required />
        <div id="period-hint" class="hint">例： 2025-09</div>
      </div>
    </div>

    <div class="row">
      <div></div>
      <button type="submit">チェック</button>
    </div>
  </form>

  <div id="results"></div>

  <script>
    // --- formatMomentum: format a decimal return as signed percentage ---
    function formatMomentum(value) {
      if (value === null || value === undefined) return 'N/A';
      const num = Number(value);
      if (!Number.isFinite(num)) return 'N/A';
      const pct = Math.round(num * 10000) / 100; // two decimals
      const normalized = Object.is(pct, -0) ? 0 : pct; // avoid -0
      const sign = normalized > 0 ? '+' : (normalized < 0 ? '' : '+');
      const absStr = Math.abs(normalized).toFixed(2);
      return (normalized < 0) ? `-${absStr}%` : `${sign}${absStr}%`;
    }

    // --- getUnitJapanese: label for unit ---
    function getUnitJapanese(unit, n) {
      const unitMap = { month: 'ヶ月', week: '週間', day: '日間' };
      const label = unitMap[unit] ?? unit;
      return `${n}${label}`;
    }

    const form = document.getElementById('momentum-form');
    const unitSelect = document.getElementById('unit');
    const periodInput = document.getElementById('as_of_period');
    const periodHint = document.getElementById('period-hint');
    const resultsDiv = document.getElementById('results');

    // --- displayResults: render the response in the required format ---
    function displayResults(data, request) {
      console.log('displayResults called with:', { data, request });
      const lines = [];

      const tickers = Array.isArray(request?.tickers) ? request.tickers : [];
      for (let i = 0; i < tickers.length; i++) {
        const ticker = tickers[i];
        const result = data?.results?.[i];
        const tickerPrices = data?.prices?.[ticker];
        
        // メインの結果行
        lines.push(`${ticker}: ${formatMomentum(result)}`);
        
        // 価格詳細情報を追加
        if (tickerPrices && tickerPrices.current !== null && tickerPrices.past !== null) {
          const currentPrice = Number(tickerPrices.current).toFixed(2);
          const pastPrice = Number(tickerPrices.past).toFixed(2);
          lines.push(`  └ 終値: ${pastPrice} → ${currentPrice}`);
        } else if (tickerPrices) {
          const currentPrice = tickerPrices.current !== null ? Number(tickerPrices.current).toFixed(2) : 'N/A';
          const pastPrice = tickerPrices.past !== null ? Number(tickerPrices.past).toFixed(2) : 'N/A';
          lines.push(`  └ 終値: ${pastPrice} → ${currentPrice} (データ不足)`);
        }
      }

      lines.push('');
      const unitJa = getUnitJapanese(request?.unit, request?.n);
      const past = data?.anchors?.past;
      const current = data?.anchors?.current;
      const hasAnchors = !!past && !!current && past !== 'N/A' && current !== 'N/A';
      if (hasAnchors) {
        lines.push(`対象期間: ${unitJa} (${past} 〜 ${current})`);
      } else {
        lines.push(`対象期間: ${unitJa} (データが不足)`);
      }
      lines.push(`基準日: ${request?.as_of_period}`);

      resultsDiv.textContent = lines.join('\n');
    }

    // Update fields by unit
    function updateUnitUI() {
      const unit = unitSelect.value;
      
      if (unit === 'month') {
        // 全ての制約属性を完全にクリア
        periodInput.removeAttribute('step');
        periodInput.removeAttribute('min');
        periodInput.removeAttribute('max');
        periodInput.type = 'month';
        periodInput.placeholder = 'YYYY-MM';
        // monthモードに切り替え時、不正な値をクリア
        if (periodInput.value && periodInput.value.includes('-') && periodInput.value.split('-').length === 3) {
          const [year, month] = periodInput.value.split('-');
          periodInput.value = `${year}-${month}`;
        }
        periodHint.textContent = '例： 2025-09';
      } else if (unit === 'week') {
        // まず一度textにリセットしてから、dateに設定（ブラウザキャッシュクリア）
        periodInput.type = 'text';
        periodInput.removeAttribute('step');
        periodInput.removeAttribute('min');
        periodInput.removeAttribute('max');
        
        // 少し待機してからdateに変更
        setTimeout(() => {
          periodInput.type = 'date';
          periodInput.placeholder = 'YYYY-MM-DD (土曜日)';
          
          // weekモードに切り替え時、monthフォーマットをdateフォーマットに変換
          if (periodInput.value && periodInput.value.match(/^\d{4}-\d{2}$/)) {
            periodInput.value = `${periodInput.value}-01`; // 月の最初の日を設定
          }
        }, 10);
        
        periodHint.textContent = '週間ベースは土曜日に設定してください';
      } else { // day
        // 全ての制約属性を完全にクリア
        periodInput.removeAttribute('step');
        periodInput.removeAttribute('min');
        periodInput.removeAttribute('max');
        periodInput.type = 'date';
        periodInput.placeholder = 'YYYY-MM-DD';
        // dayモードに切り替え時、monthフォーマットをdateフォーマットに変換
        if (periodInput.value && periodInput.value.match(/^\d{4}-\d{2}$/)) {
          periodInput.value = `${periodInput.value}-01`; // 月の最初の日を設定
        }
        periodHint.textContent = '例： 2025-09-08';
      }
    }
    unitSelect.addEventListener('change', updateUnitUI);
    updateUnitUI();

    // Auto-adjust to Saturday when unit=week
    let isAdjusting = false; // 無限ループ防止フラグ
    
    function adjustToSaturday() {
      if (unitSelect.value !== 'week' || !periodInput.value || isAdjusting) return;
      
      const originalDate = periodInput.value;
      console.log('Adjusting date:', originalDate);
      
      // 日付パース
      const [year, month, day] = originalDate.split('-').map(Number);
      if (!year || !month || !day) return; // 無効な日付の場合は処理しない
      
      const dt = new Date(year, month - 1, day);
      const dow = dt.getDay(); // 0=Sunday, 1=Monday, ..., 6=Saturday
      
      if (dow !== 6) { // not Saturday
        isAdjusting = true; // フラグを設定
        
        let daysToAdd;
        if (dow === 0) { // Sunday
          daysToAdd = 6; // Move to Saturday of the same week
        } else { // Monday to Friday
          daysToAdd = 6 - dow; // Move to Saturday of the same week
        }
        
        dt.setDate(dt.getDate() + daysToAdd);
        
        const y = dt.getFullYear();
        const m = String(dt.getMonth() + 1).padStart(2, '0');
        const d = String(dt.getDate()).padStart(2, '0');
        const newDateString = `${y}-${m}-${d}`;
        
        console.log(`Adjusted ${originalDate} (${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][dow]}) -> ${newDateString} (Sat)`);
        
        periodInput.value = newDateString;
        periodHint.textContent = '週間ベースの基準日は土曜日に自動調整されました';
        periodHint.classList.add('notice');
        
        setTimeout(() => {
          periodHint.textContent = '週間ベースは土曜日に設定してください';
          periodHint.classList.remove('notice');
          isAdjusting = false; // フラグをリセット
        }, 2000);
      }
    }
    
    // changeイベントのみに限定（inputとblurは削除）
    periodInput.addEventListener('change', adjustToSaturday);

    // Submit handler
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      resultsDiv.textContent = '';

      const tickers = Array.from(document.querySelectorAll('.ticker-input'))
        .map(i => i.value.trim().toUpperCase())
        .filter(Boolean);
      if (tickers.length === 0) {
        resultsDiv.textContent = 'エラー: チッカーを1つ以上入力してください';
        return;
      }
      if (tickers.length > 3) {
        resultsDiv.textContent = 'エラー: チッカーは最大3個まで入力できます';
        return;
      }

      const unit = unitSelect.value;
      const n = parseInt(document.getElementById('n').value, 10);
      const asOf = periodInput.value;

      const payload = { tickers, unit, n, as_of_period: asOf };

      resultsDiv.textContent = 'チェック中...';
      try {
        const res = await fetch('/compute', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();

        // Render results with helpers
        displayResults(data, payload);
      } catch (error) {
        console.error(error);
        const msg = (error && error.message) ? error.message : String(error);
        resultsDiv.textContent = `エラー: ${msg}`;
      }
    });
  </script>
</body>
</html>
